/**
 * @file process_info_app.c
 * @brief Консольное приложение для получения информации о процессах через модуль ядра
 *
 * Приложение принимает один или несколько PID через аргументы командной строки,
 * передает их в модуль ядра через интерфейс /proc/process_info и выводит
 * полученную информацию: UID пользователя, путь к исполняемому файлу и
 * командную строку запуска для каждого указанного процесса.
 */

 #include <stdio.h>    /* Для функций ввода-вывода (printf, fprintf) */
 #include <stdlib.h>   /* Для функций работы с памятью и конвертации (atoi) */
 #include <string.h>   /* Для функций работы со строками (strlen) */
 #include <unistd.h>   /* Для функций POSIX API (read, write, close) */
 #include <fcntl.h>    /* Для функций работы с файловыми дескрипторами (open) */
 
 /* Путь к файлу /proc, созданному модулем ядра */
 #define PROC_PATH "/proc/process_info"
 
 /* Максимальный размер буфера для чтения данных из /proc */
 #define BUFFER_SIZE 4096
 
 /**
  * @brief Получение информации о процессе через модуль ядра
  *
  * Функция открывает файл /proc/process_info, записывает в него PID,
  * считывает и выводит полученную информацию от модуля ядра.
  *
  * @param pid Идентификатор процесса для запроса
  */
 void get_process_info(int pid) {
     int fd;                   /* Файловый дескриптор для /proc/process_info */
     char pid_str[16];         /* Буфер для преобразования PID в строку */
     char buffer[BUFFER_SIZE]; /* Буфер для чтения данных из /proc */
     ssize_t bytes_read;       /* Количество прочитанных байт */
     
     /* Открываем файл /proc для чтения и записи */
     fd = open(PROC_PATH, O_RDWR);
     if (fd < 0) {
         /* Обрабатываем ошибку открытия файла */
         perror("Ошибка при открытии /proc/process_info");
         fprintf(stderr, "Убедитесь, что модуль ядра загружен командой 'sudo insmod process_info.ko'\n");
         exit(EXIT_FAILURE);
     }
     
     /* Преобразуем PID в строку и записываем в /proc */
     sprintf(pid_str, "%d", pid);
     if (write(fd, pid_str, strlen(pid_str)) < 0) {
         /* Обрабатываем ошибку записи в файл */
         perror("Ошибка при записи PID в /proc/process_info");
         close(fd);
         exit(EXIT_FAILURE);
     }
     
     /* Сбрасываем указатель файла на начало для последующего чтения */
     lseek(fd, 0, SEEK_SET);
     
     /* Читаем информацию о процессе из /proc */
     bytes_read = read(fd, buffer, BUFFER_SIZE - 1);
     if (bytes_read < 0) {
         /* Обрабатываем ошибку чтения из файла */
         perror("Ошибка при чтении из /proc/process_info");
         close(fd);
         exit(EXIT_FAILURE);
     }
     
     /* Добавляем нулевой символ в конец буфера для корректного вывода */
     buffer[bytes_read] = '\0';
     
     /* Выводим полученную информацию */
     printf("Информация о процессе %d:\n", pid);
     printf("%s\n", buffer);
     
     /* Закрываем файловый дескриптор */
     close(fd);
 }
 
 /**
  * @brief Главная функция программы
  *
  * Проверяет количество и корректность аргументов командной строки,
  * для каждого указанного PID вызывает функцию получения информации.
  *
  * @param argc Количество аргументов командной строки
  * @param argv Массив аргументов командной строки
  * @return Код завершения программы
  */
 int main(int argc, char *argv[]) {
     int i;
     
     /* Проверяем, что был передан хотя бы один PID */
     if (argc < 2) {
         fprintf(stderr, "Использование: %s <pid1> [pid2] [pid3] ...\n", argv[0]);
         return EXIT_FAILURE;
     }
     
     /* Обрабатываем каждый переданный PID */
     for (i = 1; i < argc; i++) {
         /* Преобразуем строку в число */
         int pid = atoi(argv[i]);
         
         /* Проверяем корректность PID */
         if (pid <= 0) {
             fprintf(stderr, "Неверный PID: %s\n", argv[i]);
             continue;
         }
         
         /* Получаем и выводим информацию о процессе */
         get_process_info(pid);
         
         /* Добавляем разделитель между информацией о разных процессах */
         if (i < argc - 1) {
             printf("----------------------------------\n");
         }
     }
     
     return EXIT_SUCCESS;
 }